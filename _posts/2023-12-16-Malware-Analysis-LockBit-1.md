---
layout: post
title: Malware Analysis. LockBit Ransomware 2022 version (LockBit 2.0)
---

LockBit ransomware (previously known as ABCD ransomware) first appeared in September 2019. In June 2021, the ransomware rebranded to LockBit 2.0, like several other families have recently. In this small research we will analyse LockBit 2.0 Ransomware sample.    

![lockbit]({{ site.baseurl }}/images/3/post.png)    

### Treat Actor

Organizations of all sizes have been adversely affected by the LockBit RaaS and its affiliates on a global scale. LockBit ranked first among global ransomware groups and RaaS providers in 2022 according to the quantity of victims reported on their data breach platform.     

The group's advertisement purports to offer the most fast encryption ransomware available. Additionally, ransomware administrators modify the malware to meet the requirements of threat actors:     

![lockbit]({{ site.baseurl }}/images/3/lockbit-1.png)    

### Target

Since June 2021, LockBit 2.0 has compromised over 50 large organisations across multiple sectors.    

*Geographies and sectors:*    

- United States    
- Europe    
- Brazil    
- Thailand   

*Industry:*   

- Professional services    
- Construction    
- High Tech    
- Manufacturing     
- Retail    
- Federal Goverment     

The ransomware LockBit 2.0 examines user and system configurations. By configuring the language to specific languages, the system remains unaffected by the attack. The following is a list of languages that LockBit 2.0 does not target:     

- Armenian   
- Azeri (Latin, Cyrillic)   
- Belarusian    
- Georgian    
- Kazakh (Cyrillic)    
- Kyrgyz (Cyrillic)    
- Turkmen    
- Uzbek (Latin, Cyrillic)    
- Russian    

### Cyber Kill Chain

![lockbit]({{ site.baseurl }}/images/3/2023-12-18_23-51.png)    

### Technical Overview

LockBit employs a hybrid cryptographic approach, combining Libsodium's `XSalsa20-Poly1305-Blake2b-Curve25519` and `AES-128-CBC` for file encryption. The configuration of the malware is encrypted using `XOR` and stored in static memory.     

With the elaborated multithreading architecture, LockBit’s performance is relatively fast compared to most ransomware in the field.     

LockBit 2.0 encrypts the victim's files and appends the `.lockbit` extension subsequent to execution. LockBit 2.0 notifies the victim of the successful completion of the attack by modifying the desktop wallpaper and appending the ransom note `Restore-My-Files.txt`.    

![lockbit]({{ site.baseurl }}/images/3/lockbit-2.png)    

### Identification

*sample.exe*     

File size: `982528 bytes`     
MD5 sum: `63dcf75ad743b292e4a6cd067ffc2c18`    
SHA-1 sum: `0d68ea228f49fdd8d044a2fb0dae9174eba73d7a`      
SHA-256 sum: `9feed0c7fa8c1d32390e1c168051267df61f11b048ec62aa5b8e66f60e8083af`     

First of all, check our sample via VirusTotal:    

![lockbit]({{ site.baseurl }}/images/3/2023-12-18_21-18.png)    

[https://www.virustotal.com/gui/file/9feed0c7fa8c1d32390e1c168051267df61f11b048ec62aa5b8e66f60e8083af](https://www.virustotal.com/gui/file/9feed0c7fa8c1d32390e1c168051267df61f11b048ec62aa5b8e66f60e8083af)    

So, 65 of 72 AV engines detect our sample as malicious.     

More of them detect file as `Ransom:Win32/Lockbit`.

*Static Analysis*    

The specified sample is a PE file (`32-bit`):    

```bash
file <sample.exe>
```

![lockbit]({{ site.baseurl }}/images/3/2023-12-18_21-22.png)    

```bash
hexdump -C <sample.exe>
```

![lockbit]({{ site.baseurl }}/images/3/2023-12-18_21-23.png)    

Metadata:     

```bash
exiftool <sample.exe>
```

![lockbit]({{ site.baseurl }}/images/3/2023-12-18_21-27.png)    

And we see that file timestamp is `2021-07-26 13:34:01+06.00`    

Executable sample is not packed by `upx`:    

```bash
upx -l <sample.exe>
```

![lockbit]({{ site.baseurl }}/images/3/2023-12-18_21-29.png)    

Analysze with DIE says that the compiler is `Microsoft Visual Studio 2017`:     

![lockbit]({{ site.baseurl }}/images/3/2023-12-18_21-32.png)    

Shannon entropy of sections:     

```bash
python3 entropy.py -f sample.exe
```

![lockbit]({{ site.baseurl }}/images/3/2023-12-18_21-36.png)    

LockBit checks the `NtGlobalFlag` field in the Process Control Block (PEB) to detect if the malware process [is being debugged](https://cocomelonc.github.io/malware/2022/09/15/malware-av-evasion-10.html).    

During debugging, the system sets the `FLG_HEAP_ENABLE_TAIL_CHECK (0x10)`, `FLG_HEAP_ENABLE_FREE_CHECK (0x20)` and `FLG_HEAP_VALIDATE_PARAMETERS (0x40)` flags in the `NtGlobalFlag` field, which is located in the PEB structure.

The `NtGlobalFlag` has the value `0x68` offset on `32-bit` Windows, the value of `0xbc` on `64-bit` Windows and both of them are set to 0:    

![lockbit]({{ site.baseurl }}/images/3/2023-12-18_22-07.png)    

Sample that is being debugged will remain stationary indefinitely.    

![lockbit]({{ site.baseurl }}/images/3/2023-12-18_22-31.png)    

As a stack string, the most critical strings in LockBit's sample are encoded and stored:    

![lockbit]({{ site.baseurl }}/images/3/2023-12-18_22-38.png)    

![lockbit]({{ site.baseurl }}/images/3/2023-12-18_23-09.png)    

This is another anti-analysis trick from this sample.    

Strings are decoded dynamically through XOR, addition, substraction, etc:    

![lockbit]({{ site.baseurl }}/images/3/2023-12-18_23-22.png)    

Looks like setting the GPO’s attributes `gPCMachineExtensionNames` and `gPCUserExtensionNames`:    

![lockbit]({{ site.baseurl }}/images/3/2023-12-18_23-27.png)    

#### Dynamic API resolving    

It's very common in malware code to obscure the name of the libraries and the APIs that they are using to hide their functionality from static analysis using what's called dynamic API loading.    

LockBit sample resolves APIs dynamically to make static analysis harder:    

![lockbit]({{ site.baseurl }}/images/3/2023-12-19_00-05.png)    

![lockbit]({{ site.baseurl }}/images/3/2023-12-19_00-49.png)    

The list of the loaded libraries:    

    activeds.dll
    advapi32.dll
    bcrypt.dll
    Comdlg32.dll
    combase.dll
    crypt32.dll
    cryptbase.dll
    gdiplus.dll
    gpredit.dll
    iphlpapi.dll
    mpr.dll
    msvcrt.dll
    netapi32.dll
    ole32.dll
    oleaut32.dll
    shell32.dll
    shlwapi.dll
    user32.dll
    win32u.dll
    wtsapi32.dll
    ws2_32.dll
    winspool.drv

#### Persistence

In order to obtain the handle of registry key, the malware sample resolves the stack string `"SOFTWARE\Microsoft Windows\CurrentVersion\Run"` and executes `RegCreateKeyExA`. Persistence via [Run keys](https://cocomelonc.github.io/tutorial/2022/04/20/malware-pers-1.html)    
